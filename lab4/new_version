#include "CL/cl.h"
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <omp.h>
#include <iostream>
#include <fstream>
#include <string>
#include <chrono>
#include <malloc.h>
#include <stdio.h>
#include <math.h>
#ifdef __APPLE__
#include <OpenCL/cl.h>
#else
#include <CL/cl.h>
#pragma comment(lib, "opencl.lib")
#endif

#define _CRT_SECURE_NO_WARNINGS
#define MAX_SOURCE_SIZE 4096

using namespace std;


std::string get_program_text() {
    std::ifstream t("source.cl");
    return std::string((std::istreambuf_iterator<char>(t)),
        std::istreambuf_iterator<char>());
}

float* init_opencl(float* matrix1,float* matrix2,int n,int k,int m) {

    clock_t begin;
    clock_t end;

    cl_platform_id platform_id;
    cl_uint error_num_platforms;
    cl_int error;
    cl_device_id device_id;
    cl_uint error_num_devices;
    cl_program program = NULL;
    cl_kernel kernel = NULL;
    begin = clock();


    error = clGetPlatformIDs(1, &platform_id, &error_num_platforms);
    if (error != CL_SUCCESS)
    {
        fprintf(stderr, "Error: Failed to create a platform group!\n");
        exit(1);

    }

    error = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_DEFAULT, 1, &device_id, &error_num_devices);
    if (error != CL_SUCCESS)
    {
        fprintf(stderr, "Error: Failed to create a device group!\n");
        exit(1);

    }
    cl_context context = clCreateContext(NULL, 1, &device_id, NULL, NULL, &error);
    if (!context)
    {
        fprintf(stderr, "Error: Failed to create a compute context!\n");
        exit(1);

    }
    cl_command_queue commands = clCreateCommandQueueWithProperties(context, device_id, 0, &error);
    if (error != CL_SUCCESS)
    {
        fprintf(stderr, "Error: Failed to create commands!\n");
        
        clReleaseContext(context);
        exit(1);
    }


    std::string src = get_program_text();
    const char* src_text = src.data();
    size_t src_length = src.size();

   
    program = clCreateProgramWithSource(context, 1, &src_text, &src_length, &error);

  
    error = clBuildProgram(program, 1, &device_id, NULL, NULL, NULL);
    if (error != CL_SUCCESS)
    {
        size_t len;
        char buffer[2048];

        fprintf(stderr, "Error: Failed to build program executable!\n");
        clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, sizeof(buffer), buffer, &len);
        fprintf(stderr, "%s\n", buffer);

        clReleaseProgram(program);
        clReleaseCommandQueue(commands);
        clReleaseContext(context);

        exit(1);
    }
   

   
    kernel = clCreateKernel(program, "matrix_mult", &error);
    if (!kernel || error != CL_SUCCESS)
    {
        fprintf(stderr, "Error: Failed to create compute kernel!\n");
       
        clReleaseProgram(program);
        clReleaseCommandQueue(commands);
        clReleaseContext(context);
        exit(1);
    }
    cl_mem matrix_buf1 = NULL;
    cl_mem matrix_buf2 = NULL;
    cl_mem matrix_buf = NULL;
    cl_mem size_buf = NULL;


    cl_float* matrix_opencl   = new(nothrow) cl_float[m * n];

    cl_int sizes[3] = { m, k, n };


    matrix_buf1 = clCreateBuffer(context, CL_MEM_READ_ONLY, sizeof(cl_float) * m * k, NULL, &error);
    matrix_buf2 = clCreateBuffer(context, CL_MEM_READ_ONLY, sizeof(cl_float) * k * n, NULL, &error);
    size_buf    = clCreateBuffer(context, CL_MEM_READ_ONLY, 3 * sizeof(cl_int), NULL, &error);
    matrix_buf  = clCreateBuffer(context, CL_MEM_READ_WRITE, sizeof(cl_float) * n * m, NULL, &error);
    if (!matrix_buf1 || !matrix_buf2 || !matrix_buf)
    {
        fprintf(stderr, "Error: Failed to allocate device memory!\n");
        
       
        clReleaseProgram(program);
        clReleaseKernel(kernel);
        clReleaseCommandQueue(commands);
        clReleaseContext(context);
        exit(1);
    }
   
    error = clEnqueueWriteBuffer(commands, matrix_buf1, CL_TRUE, 0, sizeof(cl_float) * m * k, matrix1, 0, NULL, NULL);
    error |= clEnqueueWriteBuffer(commands, matrix_buf2, CL_TRUE, 0, sizeof(cl_float) * n * k, matrix2, 0, NULL, NULL);
    error |= clEnqueueWriteBuffer(commands, size_buf, CL_TRUE, 0, 3 * sizeof(cl_int), sizes, 0, NULL, NULL);
    if (error != CL_SUCCESS)
    {
        fprintf(stderr, "Error: Failed to write to source array!\n");
        clReleaseMemObject(matrix_buf);
        clReleaseMemObject(matrix_buf1);
        clReleaseMemObject(matrix_buf2);
        clReleaseMemObject(size_buf);
        clReleaseProgram(program);
        clReleaseKernel(kernel);
        clReleaseCommandQueue(commands);
        clReleaseContext(context);
        exit(1);
    }
    error = clSetKernelArg(kernel, 0, sizeof(cl_mem), (void*)&matrix_buf1);
    error |= clSetKernelArg(kernel, 1, sizeof(cl_mem), (void*)&matrix_buf2);
    error |= clSetKernelArg(kernel, 2, sizeof(cl_mem), (void*)&matrix_buf);
    error |= clSetKernelArg(kernel, 3, sizeof(cl_mem), (void*)&size_buf);
    if (error != CL_SUCCESS)
    {
        fprintf(stderr, "Error: Failed to set kernel arguments! %d\n", error);
        clReleaseMemObject(matrix_buf);
        clReleaseMemObject(matrix_buf1);
        clReleaseMemObject(matrix_buf2);
        clReleaseMemObject(size_buf);
        clReleaseProgram(program);
        clReleaseKernel(kernel);
        clReleaseCommandQueue(commands);
        clReleaseContext(context);
        exit(1);
    }
    size_t global_work_size[1] = { m };
   
    error = clEnqueueNDRangeKernel(commands, kernel, 1, NULL, global_work_size, NULL, 0, NULL, NULL);

    error |= clEnqueueReadBuffer(commands, matrix_buf, CL_TRUE, 0, sizeof(cl_float) * n * m, matrix_opencl, 0, NULL, NULL);
    if (error != CL_SUCCESS)
    {
        fprintf(stderr, "Error: Failed to read buffer! %d\n", error);
        clReleaseMemObject(matrix_buf);
        clReleaseMemObject(matrix_buf1);
        clReleaseMemObject(matrix_buf2);
        clReleaseMemObject(size_buf);
        clReleaseProgram(program);
        clReleaseKernel(kernel);
        clReleaseCommandQueue(commands);
        clReleaseContext(context);
        exit(1);
    }

   
    for (int j = 0; j < n*m; j++) {
        printf("%f", matrix_opencl[j]);
    }
    

    end = clock();

  /*  print_matrix(&c);
    printf("Execution time: %f\n", (double)(end - begin));
*/


    clReleaseMemObject(matrix_buf);
    clReleaseMemObject(matrix_buf1);
    clReleaseMemObject(matrix_buf2);
    clReleaseMemObject(size_buf);
    clReleaseProgram(program);
    clReleaseKernel(kernel);
    clReleaseCommandQueue(commands);
    clReleaseContext(context);

    return matrix_opencl;
}

void matrix_mult(float* matrix, float* matrix1, float* matrix2, int n, int k, int m) {

    float tmp = 0.0;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            matrix[i * n + j] = 0;
            for (int f = 0; f < k; f++) {
                tmp = matrix1[i * k + f] * matrix2[f * n + j];
                matrix[i * n + j] += tmp;
            }
        }
    }


}

int main() {
    //if (argc < 5) {
    //	
    //	fprintf(stderr, "Enter the arguments in the format: program.exe device_num input_file.txt output_file.txt method");
    //	errorurn 1;
    //}
    /*int device_num = argv[1];
    string r_filename = argv[2];

    string w_filename = argv[3];

    int method = atoi(argv[4]);*/
    ifstream fin;
    int device_num = 0;
    string r_filename = "in.txt";
    string w_filename = "out.txt";
    int method = 1;

    if (device_num < 0 || device_num > 2) {
        device_num == 0;
    }

    fin.open(r_filename);

    if (!(fin.is_open())) {
        fprintf(stderr, "Cannot open file");

        return 1;
    }
    int n;
    int k;
    int m;
    float tmp;
    int counter = 0;

    fin >> n >> k >> m;
    if (fin.fail()) {
        fprintf(stderr, "Wrong file format");

        return 1;
    }


    float* matrix1 = new(nothrow) float[m * k];
    if (matrix1 == nullptr) {
        fprintf(stderr, "Memory cannot be allocated");

        return 1;

    }
    float* matrix2 = new(nothrow) float[k * n];
    if (matrix2 == nullptr) {
        fprintf(stderr, "Memory cannot be allocated");

        return 1;

    }

    float* matrix = new(nothrow) float[m * n];
    if (matrix == nullptr) {
        fprintf(stderr, "Memory cannot be allocated");

        return 1;

    }

    float* result = new(nothrow) float[m * n];
    if (result == nullptr) {
        fprintf(stderr, "Memory cannot be allocated");

        return 1;

    }

    for (int i = 0; i < m * n; i++) {
        matrix[i] = 0;
    }

    //Читаем первую матрицу
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < k; j++) {
            fin >> tmp;
            counter++;
            if (fin.fail() || (fin.eof() && (counter < (m * k)))) {
                delete[] matrix1;
                delete[] matrix2;
                delete[] matrix;
                fprintf(stderr, "Wrong file format");
                return 1;
            }
            else {
                matrix1[i * k + j] = tmp;
            }

        }
    }

    //Читаем вторую матрицу
    counter = 0;
    for (int i = 0; i < k; i++) {
        for (int j = 0; j < n; j++) {
            fin >> tmp;
            counter++;
            if (fin.fail() || (fin.eof() && (counter < (k * n)))) {
                delete[] matrix2;
                delete[] matrix1;
                delete[] matrix;
                fprintf(stderr, "Wrong file format");
                return 1;
            }
            else {
                matrix2[i * n + j] = tmp;
            }

        }
    }

    fin.close();



   

    if (method == 0) {
        matrix_mult(matrix, matrix1, matrix2, n, k, m);
    }
    else if (method == 1) {
        matrix = init_opencl(matrix1, matrix2, n, k, m);
        
    }
    else if (method == 2) {

    }
    else {
        fprintf(stderr, "Enter the method num from 0 to 2");
    }






    //Запись в файл
    ofstream fout;

    fout.open(w_filename);
    if (!(fout.is_open())) {
        fprintf(stderr, "Cannot open file");
        return 1;
    }

    fout << n << " " << m << endl;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            tmp = matrix[i * n + j];
            fout << matrix[i * n + j];
            if (j != n - 1) {
                fout << " ";
            }
        }
        fout << endl;
    }
    delete[] result;
    delete[] matrix;
    delete[] matrix1;
    delete[] matrix2;

    fout.close();


    return 0;
}
